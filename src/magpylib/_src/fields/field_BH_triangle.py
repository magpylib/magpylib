"""
Implementations of analytical expressions for the magnetic field of a triangular surface.
Computation details in function docstrings.
"""

# pylance: disable=Code is unreachable
from __future__ import annotations

from functools import partial

import array_api_extra as xpx
import numpy as np
from array_api_compat import array_namespace
from scipy.constants import mu_0 as MU0

from magpylib._src.array_api_utils import xp_promote
from magpylib._src.input_checks import check_field_input


def cross(a: np.ndarray, b: np.ndarray, xp=None):
    if xp is None:
        xp = array_namespace(a, b)
    if hasattr(xp, "linalg") and hasattr(xp.linalg, "cross"):
        return xp.linalg.cross(a, b)
    return xpx.lazy_apply(
        lambda a, b: xp.asarray(
            [
                a[..., 1] * b[..., 2] - a[..., 2] * b[..., 1],
                a[..., 2] * b[..., 0] - a[..., 0] * b[..., 2],
                a[..., 0] * b[..., 1] - a[..., 1] * b[..., 0],
            ]
        ).T,
        a,
        b,
    )


def vcross3(xp, a: np.ndarray, b: np.ndarray) -> np.ndarray:
    """
    vectorized cross product for 3d vectors. Is ~4x faster than np.cross when
    arrays are smallish. Only slightly faster for large arrays.
    input shape a,b: (n,3)
    returns: (n, 3)
    """
    # receives nan values at corners
    result = xp.asarray(
        [
            a[:, 1] * b[:, 2] - a[:, 2] * b[:, 1],
            a[:, 2] * b[:, 0] - a[:, 0] * b[:, 2],
            a[:, 0] * b[:, 1] - a[:, 1] * b[:, 0],
        ]
    )
    return result.T


def norm_vector_xp(xp, v) -> np.ndarray:
    """
    Calculates normalized orthogonal vector on a plane defined by three vertices.
    """
    a = v[:, 1, ...] - v[:, 0, ...]
    b = v[:, 2, ...] - v[:, 0, ...]
    n = cross(a, b)
    n_norm = xp.sqrt(xp.vecdot(n, n, axis=-1))
    return n / xp.expand_dims(n_norm, axis=-1)


def solid_angle_xp(xp, R: np.ndarray, r: np.ndarray) -> np.ndarray:
    """
    Vectorized computation of the solid angle of triangles.

    Triangle point indices are 1,2,3, different triangles are denoted by a,b,c,...
    The first triangle is defined as R1a, R2a, R3a.

    Input:
    R = [(R1a, R1b, R1c, ...), (R2a, R2b, R2c, ...), (R3a, R3b, R3c, ...)]
    r = [(|R1a|, |R1b|, |R1c|, ...), (|R2a|, |R2b|, |R2c|, ...), (|R3a|, |R3b|, |R3c|, ...)]

    Returns:
    [sangle_a, sangle_b, sangle_c, ...]
    """
    R0, R1, R2 = R[0, ...], R[1, ...], R[2, ...]
    r0, r1, r2 = r[0, ...], r[1, ...], r[2, ...]

    # Calculates (oriented) volume of the parallelepiped in vectorized form.
    N = xp.vecdot(
        R2,
        cross(R1, R0),
    )

    D = (
        r0 * r1 * r2
        + xp.vecdot(
            R2,
            R1,
        )
        * r0
        + xp.vecdot(
            R2,
            R0,
        )
        * r1
        + xp.vecdot(
            R1,
            R0,
        )
        * r2
    )
    result = 2.0 * xp.atan2(N, D)

    # modulus 2pi to avoid jumps on edges in line
    # "B = sigma * ((n.T * solid_angle(R, r)) - vcross3(n, PQR).T)"
    # <-- bad fix :(

    return xp.where(xp.abs(result) > 6.2831853, 0, result)


def triangle_Bfield(
    observers: np.ndarray,
    vertices: np.ndarray,
    polarizations: np.ndarray,
) -> np.ndarray:
    """Magnetic field generated by homogeneously magnetically charged triangular surfaces.

    The charge is proportional to the projection of the polarization vectors onto the
    triangle surfaces. The order of the triangle vertices defines the sign of the
    surface normal vector (right-hand-rule). The output is proportional to the
    polarization magnitude, and independent of the length units chosen for observers
    and vertices.

    Can be used to compute the field of a homogeneously magnetized bodies with triangular
    surface mesh. In this case each Triangle must be defined so that the surface normal
    vector points outwards.

    Parameters
    ----------
    observers: ndarray, shape (n,3)
        Observer positions (x,y,z) in Cartesian coordinates.

    vertices: ndarray, shape (n,3,3)
        Triangle vertex positions ((P11,P12,P13), (P21, P22, P23), ...) in Cartesian
        coordinates.

    polarizations: ndarray, shape (n,3)
        Magnetic polarization vectors.

    Returns
    -------
    B-field: ndarray, shape (n,3)
        B-field generated by Triangles at observer positions.

    Examples
    --------
    >>> import numpy as np
    >>> import magpylib as magpy
    >>> B = magpy.core.triangle_Bfield(
    ...    observers=np.array([(2,1,1), (2,2,2)]),
    ...    vertices=np.array([[(0,0,0),(0,0,1),(1,0,0)], [(0,0,0),(0,0,1),(1,0,0)]]),
    ...    polarizations=np.array([(1,1,1), (1,1,0)])*1e3,
    ... )
    >>> with np.printoptions(precision=3):
    ...    print(B)
    [[7.452 4.62  3.136]
     [2.213 2.677 2.213]]

    Notes
    -----
    Field computations implemented from Guptasarma, Geophysics, 1999, 64:1, 70-74.
    Corners give (nan, nan, nan). Edges and in-plane perp components are set to 0.
    Loss of precision when approaching a triangle as (x-edge)**2 :(
    Loss of precision with distance from the triangle as distance**3 :(
    """
    xp = array_namespace(observers, vertices, polarizations)
    observers, vertices, polarizations = xp_promote(
        observers, vertices, polarizations, force_floating=True, xp=xp
    )
    norm_vector = partial(norm_vector_xp, xp)
    solid_angle = partial(solid_angle_xp, xp)

    n = norm_vector(vertices)
    sigma = xp.vecdot(
        n,
        polarizations,
    )  # vectorized inner product

    # vertex <-> observer
    R = xp.permute_dims(vertices, (1, 0, 2)) - observers
    r2 = xp.sum(R * R, axis=-1)
    r = xp.sqrt(r2)

    # vertex <-> vertex
    L = xp.empty_like(vertices[:, 0:3, :])
    L = xpx.at(L)[:, 0, ...].set(vertices[:, 1, :] - vertices[:, 0, :])
    L = xpx.at(L)[:, 1, ...].set(vertices[:, 2, :] - vertices[:, 1, :])
    L = xpx.at(L)[:, 2, ...].set(vertices[:, 0, :] - vertices[:, 2, :])
    L = xp.permute_dims(L, (1, 0, 2))
    l2 = xp.sum(L * L, axis=-1)
    l1 = xp.sqrt(l2)

    # vert-vert -- vert-obs
    b = xp.vecdot(R, L)
    bl = b / l1
    ind = xp.abs(r + bl)  # closeness measure to corner and edge

    # The computation of ind is the origin of a major numerical instability
    #    when approaching the triangle because r ~ -bl. This number
    #    becomes small at the same rate as it looses precision.
    #    This is a major problem, because at distances 1e-8 and 1e8 all precision
    #    is already lost !!!
    # The second problem is at corner and edge extensions where ind also computes
    #    as 0. Here one approaches a special case where another evaluation should
    #    be used. This problem is solved in the following lines.
    # np.seterr must be used because of a numpy bug. It does not interpret where
    #   correctly. The following code will raise a numpy warning - but obviously shouldn't
    #
    # x = np.array([(0,1,2), (0,0,1)])
    # np.where(
    #     x>0,
    #     1/x,
    #     0
    # )
    def B_not_degenerate(l1, l2, r, r2, b, bl, ind):
        l_arg1 = xp.sqrt(l2 + 2 * b + r2) + l1 + bl
        return 1.0 / l1 * xp.log(l_arg1 / ind)

    def B_edge(l1, r):
        lr = xp.abs(l1 - r)
        return -(1.0 / l1) * xp.log(lr / r)

    def B_degenerate(l1, l2, r, r2, b, bl, ind):
        r_mask = (r != 0.0) & (xp.abs(l1 - r) > 0.0)
        return xpx.apply_where(r_mask, (l1, r), B_edge, fill_value=xp.nan)

    ind_mask = ind > 1.0e-12
    r_mask = r == 0.0
    r_copy = xp.asarray(r, copy=True)
    lr = xp.abs(l1 - r)
    lr_mask = lr == 0.0
    lr = xpx.at(lr)[ind_mask | lr_mask].set(3.0)
    ind = xpx.at(ind)[~ind_mask].set(1.0)
    r_copy = xpx.at(r_copy)[r_mask].set(1.0)

    I = xpx.apply_where(  # noqa: E741
        ind_mask,
        (l1, l2, r, r2, b, bl, ind),
        B_not_degenerate,
        B_degenerate,
        # 1.0 / l1 * xp.log(l_arg1 / ind),
        # -(1.0 / l1) * xp.log(lr / r_copy),
    )
    I = xpx.at(I)[r_mask].set(xp.nan)
    I = xpx.at(I)[lr_mask & ~ind_mask].set(xp.nan)

    PQR = xp.vecdot(I[:, :, xp.newaxis], L, axis=-3)
    B = sigma * (n.T * solid_angle(R, r) - cross(n, PQR).T)
    B = B / xp.pi / 4.0

    return B.T


def BHJM_triangle(
    field: str,
    observers: np.ndarray,
    vertices: np.ndarray,
    polarization: np.ndarray,
) -> np.ndarray:
    """
    - translate triangle core field to BHJM
    """
    check_field_input(field)

    BHJM = polarization.astype(float) * 0.0

    if field == "M":
        return BHJM

    if field == "J":
        return BHJM

    BHJM = triangle_Bfield(
        observers=observers,
        vertices=vertices,
        polarizations=polarization,
    )

    # new MU0 problem:
    #   input is polarization -> output has MU0 on it and must be B
    #   H will then be connected via MU0

    if field == "B":
        return BHJM

    if field == "H":
        return BHJM / MU0

    msg = f"`output_field_type` must be one of ('B', 'H', 'M', 'J'), got {field!r}"
    raise ValueError(msg)  # pragma: no cover
