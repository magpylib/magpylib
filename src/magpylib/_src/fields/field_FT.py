from itertools import compress

import numpy as np
import warnings
from magpylib._src.fields.field_wrap_BH import getB

def check_input_targets(targets):
    """
    Check and format targets input
    - check if allowed instance
    - check if meshing parameter is set
    
    Returns
    -------
    list of targets
    """
    if not isinstance(targets, list):
        targets = [targets]

    for t in targets:

        # check if only allowed class instances (all allowed instances have meshing parameter)
        if not hasattr(t, 'meshing'):
            msg = (
                "getFT bad target input. Targets can only be Magpylib objects Cuboid,..."
                f" Instead received type {type(t)} target."
            )
            raise ValueError(msg)

        # check if meshing parameter is explicitly set
        if t.meshing is None:
            msg = (
                f"getFT missing meshing input for target {t}."
                " All targets must have the meshing parameter explicitly set."
            )
            raise ValueError(msg)

    return targets


def check_input_pivot(pivot, targets):
    """
    Check and format pivot input
    - check if pivot has correct shape

    Returns
    -------
    list of pivots
    """
    if pivot == "centroid":
        return [t.centroid for t in targets]
    if isinstance(pivot, (list, tuple, np.ndarray)):
        pivot = np.array(pivot)
        if pivot.shape == (3,):
            return [pivot]*len(targets)
        if pivot.shape == (len(targets), 3):
            return pivot
    
    msg = (
        "Bad getFT pivot input. Input pivot must be str 'centroid'"
        " or array_like of shape (3,), or can be (n,3) when there are n targets."
    )
    raise ValueError(msg)


def create_eps_vector(eps):
    """
    Create a vector of finite difference steps based on the input eps.
    
    Parameters
    ----------
    eps : float
        The finite difference step size.

    Returns
    -------
    np.ndarray
        A vector of shape (7, 3) for finite difference calculations.
    """
    return np.array(
        [
            (0, 0, 0),
            (eps, 0, 0),
            (-eps, 0, 0),
            (0, eps, 0),
            (0, -eps, 0),
            (0, 0, eps),
            (0, 0, -eps),
        ]
    )


def getFT(sources, targets, pivot="centroid", eps=1e-5, squeeze=True):
    """
    Compute magnetic force and torque acting on the targets that are exposed
    to the magnetic field of the sources.

    SI units are assumed for all inputs and outputs.

    Parameters
    ----------
    sources: source and collection objects or 1D list thereof
        Sources that generate the magnetic field. Can be a single source (or collection)
        or a 1D list of l sources and/or collection objects.

    targets: single object or 1D list of t objects that are Sphere, Cuboid, Polyline,
        Cylinder, CylinderSegment, or Dipole. Force and Torque acting on targets in the magnetic
        field generated by the sources will be computed. A target (except of Dipole) must have a valid
        `meshing` parameter.

    pivot: array_like, default=None
        The Force adds to the Torque via the pivot point. For a freely floating magnet
        this would be the barycenter.

    eps: float, default=1e-5
        This is only used for magnet targets for computing the magnetic field gradient
        using finite differences (FD). `eps` is the FD step size. A good value
        is 1e-5 * characteristic_system_size (magnet size, distance between sources
        and targets, ...).

    squeeze: bool, default=True
        The output of the computation has the shape (n,3) where n corresponds to the number
        of targets. By default this is reduced to (3,) when there is only one target.

    Returns
    -------
    Force-Torque as ndarray of shape (2,3), or (t,2,3) when t targets are given
    """

    targets = check_input_targets(targets)
    pivot = check_input_pivot(pivot, targets)
    n = len(targets)

    mask_magnet = np.array([t._force_func.__func__ == getFT_magnet for t in targets], dtype=bool)
    mask_current = np.array([t._force_func.__func__ == getFT_current for t in targets], dtype=bool)
    tgt_types = ["magnet" if m1 else "current" if m2 else "bad" for m1,m2 in zip(mask_magnet, mask_current)]

    # The B-field is computed for all targets at once before-hand. This improves
    #    efficiency via vectorization (of the B-field computation) because each
    #    target is represented by a point-cloud of mesh vertices.
    # Later, for the force computation magnets and currents will be evaluated
    #    in separate groups.

    # transform targets into observers point clouds, store moments, lvec, currents
    observer = []
    mag_moments = []
    eps_vec = create_eps_vector(eps)
    for tgt, tgt_type in zip(targets, tgt_types):

        if tgt_type == "magnet":
            mesh, mom = tgt._generate_mesh()
            # if target is a magnet add 6 finite difference steps for gradient computation
            mesh = (mesh[:, np.newaxis, :] + eps_vec[np.newaxis, :, :]).reshape(-1, 3)
            mag_moments.append(mom)

        if tgt_type == "current":
            mesh = tgt._generate_mesh()

        observer.append(mesh)

    # mesh info for later broadcasting
    mesh_sizes = np.array([len(obs) for obs in observer])
    obs_ends = np.cumsum(mesh_sizes)
    obs_starts = np.r_[0, obs_ends[:-1]]

    # compute field in one go
    observer = np.concatenate(observer, axis=0)
    B_all = getB(sources, observer, squeeze=True)

    print(B_all.shape)

    import sys
    sys.exit()

    n_magnets = sum(mesh_sizes[mask_magnet]) // 7
    n_currents = sum(mesh_sizes[mask_current])

    # magnets
    if n_magnets > 0:
        # Array allocation for broadcasting
        POS = np.zeros((n_magnets, 3))   # central location of each cell
        B = np.zeros((n_magnets, 3))     # B-field at each cell
        DB = np.zeros((n_magnets, 3, 3)) # B-field gradient at each cell
        MOM = np.zeros((n_magnets, 3))  # magnetic moment of each cell

        # Prepare index ranges for broadcasting
        mesh_counts = mesh_sizes[mask_magnet] // 7
        idx_ends = np.cumsum(mesh_counts)
        idx_starts = np.r_[0, idx_ends[:-1]]

        # BROADCASTING
        for i, mom in enumerate(mag_moments):
            ids, ide = idx_starts[i], idx_ends[i] # index range in broadcast arrays
            start, end = obs_starts[mask_magnet][i], obs_ends[mask_magnet][i] # range in observer arrays

            POS[ids : ide] = observer[start : end : 7]
            B[ids : ide] = B_all[start : end : 7]

            # ∂B/∂x
            DB[ids : ide, :, 0] = B_all[start+1 : end : 7]
            DB[ids : ide, :, 0] -= B_all[start+2 : end : 7]
            DB[ids : ide, :, 0] /= (2*eps)

            # ∂B/∂y
            DB[ids : ide, :, 1] = B_all[start+3 : end : 7]
            DB[ids : ide, :, 1] -= B_all[start+4 : end : 7]
            DB[ids : ide, :, 1] /= (2*eps)
            
            # ∂B/∂z
            DB[ids : ide, :, 2] = B_all[start+5 : end : 7]
            DB[ids : ide, :, 2] -= B_all[start+6 : end : 7]
            DB[ids : ide, :, 2] /= (2*eps)

            MOM[ids : ide] = mom

        # ACTUAL FORCE AND TORQUE COMPUTATION
        force = np.einsum('ijk,ik->ij', DB, MOM) # this is faster than sum below
        #force = np.sum(DB * MOM[:, np.newaxis, :], axis=2)
        torque = np.cross(B, MOM)  # this is faster than einsum above
        
        F = np.add.reduceat(force, idx_starts, axis=0)
        T = np.add.reduceat(torque, idx_starts, axis=0)

    
    
    
    
    
    # if anchor is not None:
    #    Ts -= np.cross(POSS[:, 0] - anchor, Fs)
        

        return F,T
    
        Ts = np.cross(B[:, 0], MOM)
        #print(mesh_sizes[mask_magnet]//4)
        #print(len(B))
        #print(len(force))
        # import sys
        # sys.exit()

    if n_currents > 0:
        # path vector of each cell
        LVEC = np.zeros((n_currents, 3))
        # central location of each cell
        POSS = np.zeros((n_currents, 3))
        # current of each cell
        CURR = np.zeros((n_currents,))
        # B-field at cell position
        B = np.zeros((n_currents, 3))

        # # force on every instance
        # F = (CURR * np.cross(LVEC, B).T).T

        # # torque on every instance + sumup for every target
        # if anchor is not None:
        #     T = np.cross(anchor - POSS, F)
        #     T = np.array(
        #         [np.sum(T[insti[i] : insti[i + 1]], axis=0) for i in range(tgt_number)]
        #     )
        # else:
        #     T = np.zeros((tgt_number, 3))

    return 0


    # # split targets into lists of similar types
    # TARGET_TYPES = [Cuboid, Polyline, Sphere, Cylinder, CylinderSegment, Circle, Dipole]
    # getFT_FUNCS = [
    #     getFTmagnet,
    #     getFTcurrent,
    #     getFTmagnet,
    #     getFTmagnet,
    #     getFTmagnet,
    #     getFTcurrent_circ,
    #     getFTdipole,
    # ]
    # objects = [[] for _ in TARGET_TYPES]
    # orders = [[] for _ in TARGET_TYPES]

    # for i, tgt in enumerate(targets):
    #     for j, ttyp in enumerate(TARGET_TYPES):
    #         if isinstance(tgt, ttyp):
    #             objects[j].append(tgt)
    #             orders[j].append(i)

    # # allocate FT
    # FT = np.zeros((n, 2, 3))

    # # FT-computation and broadcasting
    # for i in range(len(TARGET_TYPES)):
    #     if objects[i]:
    #         ft_part = getFT_FUNCS[i](sources, objects[i], eps=eps, anchor=anchor)
    #         ft_part = np.swapaxes(ft_part, 0, 1)
    #         for ft, j in zip(ft_part, orders[i], strict=False):
    #             FT[j] = ft

    # if squeeze:
    #     return np.squeeze(FT)
    # return FT


def getFT_magnet():
    """
    Compute force and torque acting on magnets of same type

    Parameters
    ----------
    sources: source and collection objects or 1D list thereof
        Sources that generate the magnetic field. Can be a single source (or collection)
        or a 1D list of l sources and/or collection objects.

    targets: Cuboid object or 1D list of Cuboid objects
        Force and Torque acting on targets in the magnetic field generated by the sources
        will be computed. A target must have a valid `meshing` parameter.

    eps: float, default=1e-5
        The magnetic field gradient is computed using finite differences (FD). eps is
        the FD step size. A good value is 1e-5 * characteristic system size (magnet size,
        distance between sources and targets, ...).

    anchor: array_like, default=None
        The Force adds to the Torque via the anchor point. For a freely floating magnet
        this would be the barycenter. If `anchor=None`, this part of the Torque computation
        is omitted.
    """
    # number of magnets
    tgt_number = len(targets)

    # create meshes
    meshes = [mesh_target(tgt) for tgt in targets]

    # number of instances of each magnet
    inst_numbers = [len(mesh) for mesh in meshes]

    # total number of instances
    no_inst = np.sum(inst_numbers)

    # cumsum of number of instances (used for indexing)
    insti = np.r_[0, np.cumsum(inst_numbers)]

    # field computation positions (1xfor B, 6x for gradB)
    POSS = np.zeros((no_inst, 7, 3))

    # moment of each instance
    MOM = np.zeros((no_inst, 3))

    # MISSING: eps should be defined relative to the sizes of the objects
    eps_vec = np.array(
        [
            (0, 0, 0),
            (eps, 0, 0),
            (-eps, 0, 0),
            (0, eps, 0),
            (0, -eps, 0),
            (0, 0, eps),
            (0, 0, -eps),
        ]
    )

    for i, tgt in enumerate(targets):
        tgt_vol = volume(tgt)
        inst_mom = tgt.orientation.apply(tgt.magnetization) * tgt_vol / inst_numbers[i]
        MOM[insti[i] : insti[i + 1]] = inst_mom

        mesh = meshes[i]
        # mesh_target(tgt)
        # import matplotlib.pyplot as plt
        # ax = plt.figure().add_subplot(projection='3d')
        # ax.plot(mesh[:,0], mesh[:,1], mesh[:,2], ls='', marker='.')

        mesh = tgt.orientation.apply(mesh)
        # ax.plot(mesh[:,0], mesh[:,1], mesh[:,2], ls='', marker='.', color='r')
        # plt.show()
        # import sys
        # sys.exit()

        for j, ev in enumerate(eps_vec):
            POSS[insti[i] : insti[i + 1], j] = mesh + ev + tgt.position

    BB = magpy.getB(sources, POSS, sumup=True)
    if BB.ndim == 2:
        BB = np.expand_dims(BB, axis=0)
    gradB = (BB[:, 1::2] - BB[:, 2::2]) / (2 * eps)
    gradB = np.swapaxes(gradB, 0, 1)

    Fs = np.sum((gradB * MOM), axis=2).T
    # Ts = np.zeros((no_inst,3))
    Ts = np.cross(BB[:, 0], MOM)
    if anchor is not None:
        Ts -= np.cross(POSS[:, 0] - anchor, Fs)

    T = np.array(
        [np.sum(Ts[insti[i] : insti[i + 1]], axis=0) for i in range(tgt_number)]
    )
    F = np.array(
        [np.sum(Fs[insti[i] : insti[i + 1]], axis=0) for i in range(tgt_number)]
    )

    return np.array((F, -T))


def getFT_current():
    """
    Placeholder for force computation function.
    This should be replaced with the actual implementation.
    """
    """
    compute force acting on tgt Polyline
    eps is a dummy variable that is not used

    info:
    targets = Polyline objects
    segments = linear segments within Polyline objects
    instances = computation instances, each segment is split into `meshing` points
    """
    # number of Polylines
    tgt_number = len(targets)

    # segments of each Polyline
    seg_numbers = np.array([len(tgt.vertices) - 1 for tgt in targets])

    # number of mesh-points of each Polyline
    mesh_numbers = np.array([tgt.meshing for tgt in targets])

    # number of instances of each Polyline
    inst_numbers = seg_numbers * mesh_numbers

    # total number of instances
    no_inst = np.sum(inst_numbers)

    # cumsum of number of instances (used for indexing)
    insti = np.r_[0, np.cumsum(inst_numbers)]

    # path vector of each instance
    LVEC = np.zeros((no_inst, 3))
    # central location of each instance
    POSS = np.zeros((no_inst, 3))
    # current of each instance
    CURR = np.zeros((no_inst,))

    for i, tgt in enumerate(targets):
        verts = tgt.orientation.apply(tgt.vertices)
        mesh = mesh_numbers[i]

        lvec = np.repeat(verts[1:] - verts[:-1], mesh, axis=0) / mesh
        LVEC[insti[i] : insti[i + 1]] = lvec

        CURR[insti[i] : insti[i + 1]] = [tgt.current] * mesh * seg_numbers[i]

        for j in range(seg_numbers[i]):
            # pylint: disable=line-too-long
            poss = (
                np.linspace(
                    verts[j] + lvec[j * mesh] / 2,
                    verts[j + 1] - lvec[j * mesh] / 2,
                    mesh,
                )
                + tgt.position
            )
            POSS[insti[i] + mesh * j : insti[i] + mesh * (j + 1)] = poss

    # field of every instance
    B = magpy.getB(sources, POSS, sumup=True)

    # force on every instance
    F = (CURR * np.cross(LVEC, B).T).T

    # torque on every instance + sumup for every target
    if anchor is not None:
        T = np.cross(anchor - POSS, F)
        T = np.array(
            [np.sum(T[insti[i] : insti[i + 1]], axis=0) for i in range(tgt_number)]
        )
    else:
        T = np.zeros((tgt_number, 3))

    # sumup force for every target
    F = np.array(
        [np.sum(F[insti[i] : insti[i + 1]], axis=0) for i in range(tgt_number)]
    )

    return np.array((F, -T))
    
    
    
    
    
    warnings.warn("FT_current is a placeholder and should be replaced with an actual implementation.")
    return np.zeros((1, 2, 3))  # Dummy return value


def getFT_dipole():
    """
    Placeholder for force computation function.
    This should be replaced with the actual implementation.
    """
    warnings.warn("FT_magnet is a placeholder and should be replaced with an actual implementation.")
    return np.zeros((1, 2, 3))  # Dummy return value