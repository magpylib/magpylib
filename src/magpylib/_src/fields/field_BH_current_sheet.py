"""
Implementations of analytical expressions of current sheet
"""

# pylint: disable=too-many-positional-arguments
from __future__ import annotations

import numpy as np
from scipy.constants import mu_0 as MU0
from scipy.spatial.transform import Rotation as R

from magpylib._src.input_checks import check_field_input


def coordinate_transformation(vertices):
    """
    Function that transforms the triangle to elementar current sheet

    Parameters
    ----------
    vertices: ndarray, shape (n,3,3)
        Triangle vertex positions ((P11,P12,P13), (P21, P22, P23), ...) in Cartesian
        coordinates.

    Returns
    -------
    elementar_coordinates: ndarray, shape (n,3)
        Coordinates of elementar current sheet (0,0,0), (u1,0,0), (u2,v2,0)
        in the form ((u1, u2, v2), ....)

    translation: ndarray, shape (n,3)
        Translation done for the coordinate transformation.
        Sign so that elementar vertices + translation = real vertices

    rotation: scipy.rotation object
        Rotation done for the coordinate transformation.
    """

    n = len(vertices)

    # step 1
    # translate so that Pi1 -> (0,0,0)
    translation = np.copy(vertices[:, 0, :])
    vertices[:, 1, :] = vertices[:, 1, :] - translation
    vertices[:, 2, :] = vertices[:, 2, :] - translation
    vertices[:, 0, :] = 0

    # step 2
    # apply two rotations so that Pi2 -> (u1,0,0)

    # step 2.1: first rotation around x-axis so that Pi2 -> xy-plane
    theta = -np.arctan2(vertices[:, 1, 2], vertices[:, 1, 1])

    r21 = R.from_euler("x", theta)

    vertices[:, 1, :] = r21.apply(vertices[:, 1, :])
    vertices[:, 2, :] = r21.apply(vertices[:, 2, :])

    # step 2.2: second rotation around z-axis so that Pi2 -> x-axis
    alpha = -np.arctan2(vertices[:, 1, 1], vertices[:, 1, 0])

    r22 = R.from_euler("z", alpha)

    vertices[:, 1, :] = r22.apply(vertices[:, 1, :])
    vertices[:, 2, :] = r22.apply(vertices[:, 2, :])

    # step 3
    # apply rotation around x-axis so that Pi3 -> (u2,v2,0)
    psi = -np.arctan2(vertices[:, 2, 2], vertices[:, 2, 1])

    r3 = R.from_euler("x", psi)

    vertices[:, 2, :] = r3.apply(vertices[:, 2, :])

    rotation = r3 * r22 * r21

    elementar_coordinates = np.zeros((n, 3))
    elementar_coordinates[:, 0] = vertices[:, 1, 0]
    elementar_coordinates[:, 1:] = vertices[:, 2, :2]

    return (elementar_coordinates, translation, rotation)


def assign_masks(observers, coordinates, current_densities, mask):
    """helpfunction that renames input"""
    if mask is None:
        x, y, z = observers.T
        u1, u2, v2 = coordinates.T
        ju, jv = current_densities.T
    else:
        x, y, z = observers[mask, :].T
        u1, u2, v2 = coordinates[mask, :].T
        ju, jv = current_densities[mask, :].T
    return (x, y, z, u1, u2, v2, ju, jv)


# CORE
def elementar_current_sheet_Hfield(
    observers: np.ndarray,
    coordinates: np.ndarray,
    current_densities: np.ndarray,
) -> np.ndarray:
    """H-field of current sheets.

    The elementar current sheet is defined as the triangle with the vertices
    (0,0,0), (u1,0,0), (u2,v2,0).
    The current flows in the direction of current_density.
    The field is set to (0,0,0) on the sheet itself.
    The output is proportional to the current and independent of the length units
    chosen for observers and dimensions.

    Parameters
    ----------
    observers: ndarray, shape (n,3)
        Observer positions (x,y,z) in Cartesian coordinates.

    coordinates: ndarray, shape (n,3)
        Defining coordinates of elementar current sheet (0,0,0), (u1,0,0), (u2,v2,0), where
        u1, u2, v2 = coordinates

    current_densities: ndarray, shape (n,2)
        x- and y-coordinates of electrical current densities in sheets.
        Since elementar current sheet lies in x-y-plane, no z-coordinate required.

    Returns
    -------
    H-Field: ndarray, shape (n,3)
        H-field generated by current sheets at observer positions.

    Notes
    -----
    Field computation via law of Biot Savart. See also countless online resources.
    eg. http://www.phys.uri.edu/gerhard/PHY204/tsl216.pdf
    """
    # tolerance for numerical errors
    num_tol = 1e-10

    # rename
    x, y, z, u1, u2, v2, ju, jv = assign_masks(
        observers, coordinates, current_densities, None
    )

    # in-plane with triangle
    in_plane = np.abs(z) < num_tol

    # critical value for condition, if observer within triangle or on the edges
    critical_value01 = (x * v2 - y * u2) / (u1 * v2)  # within triangle
    critical_value02 = y / v2  # within triangle
    critical_value1 = np.abs(y)  # edge1
    critical_value2 = np.abs(u2 * y - v2 * x)  # edge2
    critical_value3 = np.abs(v2 * (x - u1) + y * (u1 - u2))  # edge3

    # separate on-sheet cases (-> B=0)
    mask0 = (
        in_plane
        & (critical_value01 + critical_value02 <= 1 + num_tol)
        & (critical_value01 >= -num_tol)
        & (critical_value02 >= -num_tol)
    )
    # each condition account for numerical issues

    # separate on-edge cases
    mask1 = in_plane & (critical_value1 < num_tol) & ~mask0
    mask2 = in_plane & (critical_value2 < num_tol) & ~mask0
    mask3 = in_plane & (critical_value3 < num_tol) & ~mask0
    mask_plane = ~(mask0 | mask1 | mask2 | mask3) & in_plane
    mask_general = ~in_plane

    special_cases = not all(mask_general)

    # allocate
    H = np.zeros_like(observers, dtype=float)

    # CASE: GENERAL ###############################################################
    if special_cases:
        x, y, z, u1, u2, v2, ju, jv = assign_masks(
            observers, coordinates, current_densities, mask_general
        )

    sqrt1 = np.sqrt(x**2 + y**2 + z**2)
    sqrt2 = np.sqrt(u1**2 - 2 * u1 * x + x**2 + y**2 + z**2)
    sqrt3 = np.sqrt(u2**2 - 2 * u2 * x + v2**2 - 2 * v2 * y + x**2 + y**2 + z**2)
    sqrt4 = np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
    sqrt5 = np.sqrt(u2**2 + v2**2)

    H[mask_general, 0] = (
        np.arctan((-u2 * (y**2 + z**2) + v2 * x * y) / (v2 * z * sqrt1))
        + np.arctan((v2 * y * (u1 - x) - (u1 - u2) * (y**2 + z**2)) / (v2 * z * sqrt2))
        - np.arctan(
            (-u2 * (y**2 + z**2) - v2**2 * x + v2 * y * (u2 + x)) / (v2 * z * sqrt3)
        )
        - np.arctan(
            (
                -u1 * (v2**2 - 2 * v2 * y + y**2 + z**2)
                + u2 * (y**2 + z**2)
                + v2**2 * x
                - v2 * y * (u2 + x)
            )
            / (v2 * z * sqrt3)
        )
    ) / (u1 * v2 * z)
    H[mask_general, 2] = -(
        ju * np.arctanh(x / sqrt1)
        + ju * np.arctanh((u1 - x) / sqrt2)
        - (ju * (u1 - u2) - jv * v2)
        * np.arctanh((u1**2 - u1 * (u2 + x) + u2 * x + v2 * y) / (sqrt4 * sqrt2))
        / sqrt4
        + (ju * (u1 - u2) - jv * v2)
        * np.arctanh(
            (u1 * (u2 - x) - u2**2 + u2 * x + v2 * (-v2 + y)) / (sqrt4 * sqrt3)
        )
        / sqrt4
        + (ju * u2 + jv * v2) * np.arctanh((-u2 * x - v2 * y) / (sqrt5 * sqrt1)) / sqrt5
        - (ju * u2 + jv * v2)
        * np.arctanh((u2**2 - u2 * x + v2 * (v2 - y)) / (sqrt5 * sqrt3))
        / sqrt5
    ) / (u1 * v2)

    if special_cases:
        # CASE: Observer in plane ################################################################
        x, y, z, u1, u2, v2, ju, jv = assign_masks(
            observers, coordinates, current_densities, mask_plane
        )
        H[mask_plane, 2] = -(
            ju * np.arctanh(x / np.sqrt(x**2 + y**2))
            + ju * np.arctanh((u1 - x) / np.sqrt(u1**2 - 2 * u1 * x + x**2 + y**2))
            - (ju * (u1 - u2) - jv * v2)
            * np.arctanh(
                (u1**2 - u1 * (u2 + x) + u2 * x + v2 * y)
                / (
                    np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
                    * np.sqrt(u1**2 - 2 * u1 * x + x**2 + y**2)
                )
            )
            / np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
            + (ju * (u1 - u2) - jv * v2)
            * np.arctanh(
                (u1 * (u2 - x) - u2**2 + u2 * x + v2 * (-v2 + y))
                / (
                    np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
                    * np.sqrt(u2**2 - 2 * u2 * x + v2**2 - 2 * v2 * y + x**2 + y**2)
                )
            )
            / np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
            + (ju * u2 + jv * v2)
            * np.arctanh(
                (-u2 * x - v2 * y) / (np.sqrt(u2**2 + v2**2) * np.sqrt(x**2 + y**2))
            )
            / np.sqrt(u2**2 + v2**2)
            - (ju * u2 + jv * v2)
            * np.arctanh(
                (u2**2 - u2 * x + v2 * (v2 - y))
                / (
                    np.sqrt(u2**2 + v2**2)
                    * np.sqrt(u2**2 - 2 * u2 * x + v2**2 - 2 * v2 * y + x**2 + y**2)
                )
            )
            / np.sqrt(u2**2 + v2**2)
        ) / (u1 * v2)

        # CASE: Observer on edge1 ##############################################################

        x, y, z, u1, u2, v2, ju, jv = assign_masks(
            observers, coordinates, current_densities, mask1
        )
        H[mask1, 2] = (
            -ju * x * np.log(np.abs(x)) / np.sqrt(x**2)
            - ju * (u1 - x) * np.log(np.abs(-u1 + x)) / np.sqrt((u1 - x) ** 2)
            + (ju * (u1 - u2) - jv * v2)
            * np.arctanh(
                (u1 * (-u2 + x) + u2**2 - u2 * x + v2**2)
                / (
                    np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
                    * np.sqrt(u2**2 - 2 * u2 * x + v2**2 + x**2)
                )
            )
            / np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
            + (ju * (u1 - u2) - jv * v2)
            * np.arctanh(
                (u1 - u2)
                * (u1 - x)
                / (
                    np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
                    * np.sqrt((u1 - x) ** 2)
                )
            )
            / np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
            + (ju * u2 + jv * v2)
            * np.arctanh(
                (u2**2 - u2 * x + v2**2)
                / (np.sqrt(u2**2 + v2**2) * np.sqrt(u2**2 - 2 * u2 * x + v2**2 + x**2))
            )
            / np.sqrt(u2**2 + v2**2)
            - (ju * u2 + jv * v2)
            * np.arctanh(
                u2 * (u1 - x) / (np.sqrt(u2**2 + v2**2) * np.sqrt((u1 - x) ** 2))
            )
            / np.sqrt(u2**2 + v2**2)
        ) / (u1 * v2)

        # CASE: Observer on edges 2 ##############################################################

        x, y, z, u1, u2, v2, ju, jv = assign_masks(
            observers, coordinates, current_densities, mask2
        )
        H[mask2, 2] = (
            -ju
            * np.arctanh(
                (u1 * v2 - u2 * y)
                / (
                    v2
                    * np.sqrt(u1**2 - 2 * u1 * u2 * y / v2 + y**2 * (u2**2 / v2**2 + 1))
                )
            )
            + ju
            * np.arctanh(
                u2 * (v2 - y) / (v2 * np.sqrt((u2**2 + v2**2) * (v2 - y) ** 2 / v2**2))
            )
            + (ju * (u1 - u2) - jv * v2)
            * np.arctanh(
                (u1**2 * v2 - u1 * u2 * (v2 + y) + y * (u2**2 + v2**2))
                / (
                    v2
                    * np.sqrt(u1**2 - 2 * u1 * u2 * y / v2 + y**2 * (u2**2 / v2**2 + 1))
                    * np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
                )
            )
            / np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
            + (ju * (u1 - u2) - jv * v2)
            * np.arctanh(
                (v2 - y)
                * (-u1 * u2 + u2**2 + v2**2)
                / (
                    v2
                    * np.sqrt((u2**2 + v2**2) * (v2 - y) ** 2 / v2**2)
                    * np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
                )
            )
            / np.sqrt(u1**2 - 2 * u1 * u2 + u2**2 + v2**2)
            + y
            * (ju * u2 + jv * v2)
            * np.log(np.abs(y * (-(u2**2) - v2**2)))
            / (v2 * np.sqrt(y**2 * (u2**2 + v2**2) / v2**2))
            + (v2 - y)
            * (ju * u2 + jv * v2)
            * np.log(np.abs((u2**2 + v2**2) * (v2 - y)))
            / (v2 * np.sqrt((u2**2 + v2**2) * (v2 - y) ** 2 / v2**2))
        ) / (u1 * v2)

        # CASE: Observer on edges 3 ##############################################################

        x, y, z, u1, u2, v2, ju, jv = assign_masks(
            observers, coordinates, current_densities, mask3
        )
        H[mask3, 2] = (
            ju
            * v2
            * np.arctanh(
                (u1 * (-v2 + y) - u2 * y)
                / (
                    v2
                    * np.sqrt(
                        (
                            u1**2 * (v2 - y) ** 2
                            + 2 * u1 * u2 * y * (v2 - y)
                            + y**2 * (u2**2 + v2**2)
                        )
                        / v2**2
                    )
                )
            )
            + ju
            * v2
            * np.arctanh(
                (u1 - u2)
                * (v2 - y)
                / (
                    v2
                    * np.sqrt(
                        (v2 - y) ** 2 * (u1**2 - 2 * u1 * u2 + u2**2 + v2**2) / v2**2
                    )
                )
            )
            - v2
            * (ju * u2 + jv * v2)
            * np.arctanh(
                (u1 * u2 * (-v2 + y) + y * (-(u2**2) - v2**2))
                / (
                    v2
                    * np.sqrt(
                        (
                            u1**2 * (v2 - y) ** 2
                            + 2 * u1 * u2 * y * (v2 - y)
                            + y**2 * (u2**2 + v2**2)
                        )
                        / v2**2
                    )
                    * np.sqrt(u2**2 + v2**2)
                )
            )
            / np.sqrt(u2**2 + v2**2)
            + v2
            * (ju * u2 + jv * v2)
            * np.arctanh(
                (v2 - y)
                * (-u1 * u2 + u2**2 + v2**2)
                / (
                    v2
                    * np.sqrt(
                        (v2 - y) ** 2 * (u1**2 - 2 * u1 * u2 + u2**2 + v2**2) / v2**2
                    )
                    * np.sqrt(u2**2 + v2**2)
                )
            )
            / np.sqrt(u2**2 + v2**2)
            - y
            * (ju * (-u1 + u2) + jv * v2)
            * np.log(np.abs(y * (-(u1**2) + 2 * u1 * u2 - u2**2 - v2**2)))
            / np.sqrt(y**2 * (u1**2 - 2 * u1 * u2 + u2**2 + v2**2) / v2**2)
            - (v2 - y)
            * (ju * (-u1 + u2) + jv * v2)
            * np.log(np.abs((v2 - y) * (u1**2 - 2 * u1 * u2 + u2**2 + v2**2)))
            / np.sqrt((v2 - y) ** 2 * (u1**2 - 2 * u1 * u2 + u2**2 + v2**2) / v2**2)
        ) / (u1 * v2**2)

    H[:, 1] = H[:, 0]  # copy?

    # All cases again
    x, y, z, u1, u2, v2, ju, jv = assign_masks(
        observers, coordinates, current_densities, None
    )
    H[:, 0] *= jv * z * u1 * v2 / (4 * np.pi)
    H[:, 1] *= -ju * z * u1 * v2 / (4 * np.pi)
    H[:, 2] *= u1 * v2 / (4 * np.pi)

    return H


def current_sheet_Hfield(
    observers: np.ndarray,
    vertices: np.ndarray,
    current_densities: np.ndarray,
) -> np.ndarray:
    """H-field of triangular current sheets.

    Parameters
    ----------
    observers: ndarray, shape (n,3)
        Observer positions (x,y,z) in Cartesian coordinates.

    vertices: ndarray, shape (n,3,3)
        Triangle vertex positions ((P11,P12,P13), (P21, P22, P23), ...) in Cartesian
        coordinates.

    current_densities: ndarray, shape (n,3)
        Electrical current density vectors. The current density in a sheet is the
        projection of the current density vector onto the sheet.

    Returns
    -------
    H-Field: ndarray, shape (n,3)
        H-field generated by current sheets at observer positions.
    """
    # pylint: disable=too-many-statements

    coordinates, t, r = coordinate_transformation(vertices.astype(float))

    observers = np.copy(r.apply(observers - t))
    current_densities = np.copy(r.apply(current_densities)[:, :2])

    H = np.zeros_like(observers, dtype=float)

    # just renaming
    u1, u2, v2 = coordinates.T

    # Check for zero-length segments (or discontinuous)
    mask_nan_u1 = np.isnan(u1)
    mask_nan_u2 = np.isnan(u2)
    mask_nan_v2 = np.isnan(v2)
    mask_degenerated = (np.abs(u1) < 1e-15) | (np.abs(v2) < 1e-15)
    mask0 = mask_nan_u1 | mask_nan_u2 | mask_nan_v2 | mask_degenerated
    not_mask0 = ~mask0  # avoid multiple computation of ~mask

    if np.all(mask0):
        return H

    # continue only with non-zero segments
    if np.any(mask0):
        observers = observers[not_mask0]
        coordinates = coordinates[not_mask0]
        current_densities = current_densities[not_mask0]

    H[not_mask0] = elementar_current_sheet_Hfield(
        observers=observers,
        coordinates=coordinates,
        current_densities=current_densities,
    )

    return r.apply(H, inverse=True)


def BHJM_current_sheet(
    field: str,
    observers: np.ndarray,
    vertices: np.ndarray,
    current_densities: np.ndarray,
) -> np.ndarray:
    """
    - translate current sheet field to BHJM
    """
    # pylint: disable=too-many-statements

    check_field_input(field)

    BHJM = current_sheet_Hfield(observers, vertices, current_densities)

    if field == "H":
        return BHJM

    if field == "B":
        return BHJM * MU0

    if field in ["J", "M"]:
        return observers * 0.0

    msg = f"`output_field_type` must be one of ('B', 'H', 'J', 'M'), got {field!r}"
    raise ValueError(msg)  # pragma: no cover


def BHJM_current_trisheet(
    field: str,
    observers: float | np.ndarray,
    current_densities: float | np.ndarray,
    vertices: float | np.ndarray,
    faces: int | np.ndarray,
) -> np.ndarray:
    """
    Translates TriangleSheet inputs to core BHJM current_sheet

    Parameters
    ----------
    field: 'B', 'H', 'J', 'M'
    observers: shape (n_path * n_obs, 3)
    vertices: n_observer ragged instances of (n_verts,3)
    faces: n_observer ragged instances of (n_faces,3)
    current_densities: n_observer ragged instances of (n_current_densities,3) = (n_faces,3)

    Returns
    -------
    field as shape (n_observers, 3)
    """
    # number of triangles per instance
    no_tris = [len(f) for f in faces]
    n = sum(no_tris)

    # create obs input
    OBS = np.repeat(observers, no_tris, axis=0)

    # create triangles and current_density inputs
    CDS = np.zeros((n, 3), dtype=float)
    TRIAS = np.zeros((n, 3, 3), dtype=float)
    ii = 0
    for verts, facs, cds in zip(vertices, faces, current_densities, strict=True):
        mesh = verts[facs]
        for tria, cd in zip(mesh, cds, strict=True):
            TRIAS[ii] = tria
            CDS[ii] = cd
            ii += 1

    # compute field for all instances
    BB = BHJM_current_sheet(
        field=field,
        observers=OBS,
        vertices=TRIAS,
        current_densities=CDS,
    )

    # sum over triangles of same strip
    B = np.zeros_like(observers, dtype=float)

    jj = 0
    for i, nn in enumerate(no_tris):
        B[i] = np.sum(BB[jj : jj + nn], axis=0)
        jj += nn

    return B


def BHJM_current_tristrip(
    field: str,
    observers: np.ndarray,
    vertices: np.ndarray,
    current: float,
) -> np.ndarray:
    """
    Translates TriangleStrip inputs to core BHJM current_sheet

    Note: This is not easily vectorized, as vertices inputs can be ragged arrays
    when two TriangleStrips with different vertex lengths are given.
    """

    # number of triangles per instance
    no_tris = [len(v) - 2 for v in vertices]
    n = sum(no_tris)

    # create obs input
    OBS = np.repeat(observers, no_tris, axis=0)

    # create triangles
    VERT = np.zeros((n, 3, 3), dtype=float)
    jj = 0
    for v in vertices:
        for i in range(len(v) - 2):
            VERT[jj, 0] = v[i]
            VERT[jj, 1] = v[i + 1]
            VERT[jj, 2] = v[i + 2]
            jj += 1

    # create current density input
    v1 = VERT[:, 1] - VERT[:, 0]
    v2 = VERT[:, 2] - VERT[:, 0]
    v1v1 = np.sum(v1 * v1, axis=1)
    v2v2 = np.sum(v2 * v2, axis=1)
    v1v2 = np.sum(v1 * v2, axis=1)

    CD = np.zeros((n, 3), dtype=float)

    # catch two times the same vertex in one triangle, and set CD to zero there
    mask = (v2v2 != 0) * (v1v1 != 0)
    h = np.sqrt(v1v1[mask] - (v1v2[mask] ** 2 / v2v2[mask]))
    CD[mask] = (
        v2[mask]
        / (np.sqrt(v2v2[mask]) * h / np.repeat(current, no_tris, axis=0)[mask])[
            :, np.newaxis
        ]
    )

    # compute field for all instances
    BB = BHJM_current_sheet(
        field=field,
        observers=OBS,
        vertices=VERT,
        current_densities=CD,
    )

    # sum over triangles of same strip
    B = np.zeros_like(observers, dtype=float)

    jj = 0
    for i, nn in enumerate(no_tris):
        B[i] = np.sum(BB[jj : jj + nn], axis=0)
        jj += nn

    return B


# def BHJM_current_strip_noRagged(
#     field: str,
#     observers: np.ndarray,
#     vertices: np.ndarray,
#     current: float,
# ) -> np.ndarray:
#     """
#     - translate TriangleStrip field to BHJM
#     MISSING: If multiple TriangleStrips with different vertex lengths are given
#         - add function that tests this
#         - compute for each "ragged instance" separately (its just an edge case - no one cares)
#     """

#     # create triangles from vertices
#     tris = np.moveaxis(np.moveaxis(np.array([vertices[:,:-2], vertices[:,1:-1], vertices[:,2:]]), 0, 1) , 1, 2)

#     # calculate current density
#     v1 = (tris[:,:,1]-tris[:,:,0])
#     v2 = (tris[:,:,2]-tris[:,:,0])
#     v1v1 = np.sum(v1*v1, axis=2)
#     v2v2 = np.sum(v2*v2, axis=2)
#     v1v2 = np.sum(v1*v2, axis=2)
#     h = np.sqrt(v1v1 - (v1v2**2/v2v2))

#     curr_dens = v2 / (np.sqrt(v2v2) * h / current[:,np.newaxis])[:,:,np.newaxis]

#     #store shape for later reshaping
#     tshape = tris.shape

#     # compute for all instances of observers x triangles
#     bhjm_all = BHJM_current_sheet(
#             field=field,
#             observers=np.repeat(observers, tshape[1], axis=0),
#             vertices=np.reshape(tris, (tshape[0]*tshape[1], *tshape[2:])),
#             current_densities=np.reshape(curr_dens, (tshape[0]*tshape[1], 3)),
#     )

#     # sum over all triangles
#     bhjm = bhjm_all.reshape((tris.shape[0], tris.shape[1], 3))
#     return np.sum(bhjm, axis=1)
