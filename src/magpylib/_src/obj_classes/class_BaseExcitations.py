"""Base classes for all sources excitations and getBHJM."""

# pylint: disable=cyclic-import
# pylint: disable=too-many-positional-arguments

from typing import ClassVar

import numpy as np

from magpylib._src.fields.field_BH import _getBH_level2
from magpylib._src.input_checks import (
    check_format_input_scalar,
    check_format_input_vector,
    validate_field_func,
)
from magpylib._src.obj_classes.class_BaseDisplayRepr import BaseDisplayRepr
from magpylib._src.obj_classes.class_BaseGeo import BaseGeo
from magpylib._src.style import CurrentStyle, MagnetStyle
from magpylib._src.utility import format_star_input


class BaseSource(BaseGeo, BaseDisplayRepr):
    """Base class for all source objects providing getBHJM and field function hook."""

    _field_func = None
    _field_func_kwargs_ndim: ClassVar[dict[str, int]] = {}
    _editable_field_func = False

    def __init__(self, position, orientation, field_func=None, style=None, **kwargs):
        if field_func is not None:
            self.field_func = field_func
        BaseGeo.__init__(self, position, orientation, style=style, **kwargs)
        BaseDisplayRepr.__init__(self)

    @property
    def field_func(self):
        """Function for B- and H-field computation.

        The callable must accept the two positional arguments ``field`` and ``observers``.
        With ``field='B'`` or ``field='H'`` the function must return the B-field
        (T) or H-field (A/m) respectively. ``observers`` is an ``ndarray`` of
        shape (n, 3) in units (m). The returned array must have shape (n, 3).
        """
        return self._field_func

    @field_func.setter
    def field_func(self, val):
        """Set field function."""
        if self._editable_field_func:
            validate_field_func(val)
        else:
            msg = "The field_func attribute should not be edited for original Magpylib sources."
            raise AttributeError(msg)
        self._field_func = val

    def getB(
        self, *observers, squeeze=True, pixel_agg=None, output="ndarray", in_out="auto"
    ):
        """Return B-field (T) at o observers generated by the source.

        SI units are used for all inputs and outputs.

        Parameters
        ----------
        *observers : Sensor | list[Sensor] | array-like, shape (o1, o2, ..., 3)
            Input specifying where the field is evaluated. Each entry can be an
            array-like of positions in units (m), a ``Sensor`` object with pixel shape
            (o1, o2, ..., 3) or a list of such objects (all with identical pixel
            shape unless ``pixel_agg`` is used).
        squeeze : bool, default True
            If ``True`` squeeze singleton axes (e.g. a single source or a single sensor).
        pixel_agg : str | None, default None
            Name of a NumPy aggregation function (e.g. ``'mean'``, ``'min'``) applied over the
            pixel axis of each sensor. Allows mixing sensors with different pixel shapes.
        output : {'ndarray', 'dataframe'}, default 'ndarray'
            Output container type. 'dataframe' returns a pandas DataFrame.
        in_out : {'auto', 'inside', 'outside'}, default 'auto'
            Assumption about observer locations relative to magnet bodies. ``'auto'`` detects per
            observer (safest, slower). ``'inside'`` treats all inside (faster). ``'outside'`` treats
            all outside (faster).

        Returns
        -------
        ndarray | DataFrame
            B-field (T) with squeezed shape (p, o, o1, o2, ..., 3) where p is the path length
            and o the number of observers.

        Examples
        --------
        Compute the B-field of a spherical magnet at three positions:

        >>> import numpy as np
        >>> import magpylib as magpy
        >>> src = magpy.magnet.Sphere(polarization=(0, 0, 1.0), diameter=1)
        >>> B = src.getB(((0, 0, 0), (1, 0, 0), (2, 0, 0)))
        >>> with np.printoptions(precision=3):
        ...     print(B)
        [[ 0.     0.     0.667]
         [ 0.     0.    -0.042]
         [ 0.     0.    -0.005]]

        Compute the B-field at two sensors, each one with two pixels:

        >>> sens1 = magpy.Sensor(position=(1, 0, 0), pixel=((0, 0, 0.1), (0, 0, -0.1)))
        >>> sens2 = sens1.copy(position=(2, 0, 0))
        >>> B = src.getB(sens1, sens2)
        >>> with np.printoptions(precision=3):
        ...     print(B)
        [[[ 0.012  0.    -0.04 ]
          [-0.012  0.    -0.04 ]]
        <BLANKLINE>
         [[ 0.001  0.    -0.005]
          [-0.001  0.    -0.005]]]
        """
        observers = format_star_input(observers)
        return _getBH_level2(
            self,
            observers,
            field="B",
            sumup=False,
            squeeze=squeeze,
            pixel_agg=pixel_agg,
            output=output,
            in_out=in_out,
        )

    def getH(
        self, *observers, squeeze=True, pixel_agg=None, output="ndarray", in_out="auto"
    ):
        """Return H-field (A/m) at o observers generated by the source.

        SI units are used for all inputs and outputs.

        Parameters
        ----------
        *observers : Sensor | array-like, shape (o1, o2, ..., 3)
            Input specifying where the field is evaluated. Each entry can be an
            array-like of positions in units (m), a ``Sensor`` object with pixel shape
            (o1, o2, ..., 3) or a list of such objects (all with identical pixel
            shape unless ``pixel_agg`` is used).
        squeeze : bool, default True
            If ``True`` squeeze singleton axes (e.g. a single source or a single sensor).
        pixel_agg : str | None, default None
            Name of a NumPy aggregation function (e.g. ``'mean'``, ``'min'``) applied over the
            pixel axis of each sensor. Allows mixing sensors with different pixel shapes.
        output : {'ndarray', 'dataframe'}, default 'ndarray'
            Output container type. 'dataframe' returns a pandas DataFrame.
        in_out : {'auto', 'inside', 'outside'}, default 'auto'
            Assumption about observer locations relative to magnet bodies. ``'auto'`` detects per
            observer (safest, slower). ``'inside'`` treats all inside (faster). ``'outside'`` treats
            all outside (faster).

        Returns
        -------
        ndarray | DataFrame
            H-field (A/m) with squeezed shape (p, o, o1, o2, ..., 3) where p is the path length
            and o the number of observers.

        Examples
        --------
        Compute the H-field of a spherical magnet at three positions:

        >>> import numpy as np
        >>> import magpylib as magpy

        >>> src = magpy.magnet.Sphere(polarization=(0, 0, 1), diameter=1)
        >>> H = src.getH(((0, 0, 0), (1, 0, 0), (2, 0, 0)))
        >>> with np.printoptions(precision=0):
        ...     print(H)
        [[      0.       0. -265258.]
         [      0.       0.  -33157.]
         [      0.       0.   -4145.]]

        Compute the H-field at two sensors, each one with two pixels

        >>> sens1 = magpy.Sensor(position=(1, 0, 0), pixel=((0, 0, 0.1), (0, 0, -0.1)))
        >>> sens2 = sens1.copy(position=(2, 0, 0))
        >>> H = src.getH(sens1, sens2)
        >>> with np.printoptions(precision=0):
        ...     print(H)
        [[[  9703.      0. -31696.]
          [ -9703.      0. -31696.]]
        <BLANKLINE>
         [[   618.      0.  -4098.]
          [  -618.      0.  -4098.]]]
        """
        observers = format_star_input(observers)
        return _getBH_level2(
            self,
            observers,
            field="H",
            sumup=False,
            squeeze=squeeze,
            pixel_agg=pixel_agg,
            output=output,
            in_out=in_out,
        )

    def getM(
        self, *observers, squeeze=True, pixel_agg=None, output="ndarray", in_out="auto"
    ):
        """Return magnetization (A/m) at o observers generated by the source.

        SI units are used for all inputs and outputs.

        Parameters
        ----------
        *observers : Sensor | array-like, shape (o1, o2, ..., 3)
            Input specifying where the field is evaluated. Each entry can be an
            array-like of positions in units (m), a ``Sensor`` object with pixel shape
            (o1, o2, ..., 3) or a list of such objects (all with identical pixel
            shape unless ``pixel_agg`` is used).
        squeeze : bool, default True
            If ``True`` squeeze singleton axes (e.g. a single source or a single sensor).
        pixel_agg : str | None, default None
            Name of a NumPy aggregation function (e.g. ``'mean'``, ``'min'``) applied over the
            pixel axis of each sensor. Allows mixing sensors with different pixel shapes.
        output : {'ndarray', 'dataframe'}, default 'ndarray'
            Output container type. 'dataframe' returns a pandas DataFrame.
        in_out : {'auto', 'inside', 'outside'}, default 'auto'
            Assumption about observer locations relative to magnet bodies. ``'auto'`` detects per
            observer (safest, slower). ``'inside'`` treats all inside (faster). ``'outside'`` treats
            all outside (faster).

        Returns
        -------
        ndarray or DataFrame
            Magnetization (A/m) with squeezed shape (p, o, o1, o2, ..., 3) where p is the path length
            and o the number of observers.

        Examples
        --------
        In this example we test the magnetization at an observer point.

        >>> import numpy as np
        >>> import magpylib as magpy
        >>> cube = magpy.magnet.Cuboid(
        ...     dimension=(10, 1, 1),
        ...     polarization=(1, 0, 0)
        ... ).rotate_from_angax(45, 'z')
        >>> M = cube.getM((3, 3, 0))
        >>> with np.printoptions(precision=0):
        ...    print(M)
        [562698. 562698.      0.]
        """
        observers = format_star_input(observers)
        return _getBH_level2(
            self,
            observers,
            field="M",
            sumup=False,
            squeeze=squeeze,
            pixel_agg=pixel_agg,
            output=output,
            in_out=in_out,
        )

    def getJ(
        self, *observers, squeeze=True, pixel_agg=None, output="ndarray", in_out="auto"
    ):
        """Return magnetic polarization (T) at o observers generated by the source.

        SI units are used for all inputs and outputs.

        Parameters
        ----------
        *observers : Sensor | array-like, shape (o1, o2, ..., 3)
            Input specifying where the field is evaluated. Each entry can be an
            array-like of positions in units (m), a ``Sensor`` object with pixel shape
            (o1, o2, ..., 3) or a list of such objects (all with identical pixel
            shape unless ``pixel_agg`` is used).
        squeeze : bool, default True
            If ``True`` squeeze singleton axes (e.g. a single source or a single sensor).
        pixel_agg : str | None, default None
            Name of a NumPy aggregation function (e.g. ``'mean'``, ``'min'``) applied over the
            pixel axis of each sensor. Allows mixing sensors with different pixel shapes.
        output : {'ndarray', 'dataframe'}, default 'ndarray'
            Output container type. 'dataframe' returns a pandas DataFrame.
        in_out : {'auto', 'inside', 'outside'}, default 'auto'
            Assumption about observer locations relative to magnet bodies. ``'auto'`` detects per
            observer (safest, slower). ``'inside'`` treats all inside (faster). ``'outside'`` treats
            all outside (faster).

        Returns
        -------
        ndarray or DataFrame
            Polarization (T) with squeezed shape (p, o, o1, o2, ..., 3) where p is the path length
            and o the number of observers.

        Examples
        --------
        In this example we test the polarization at an observer point.

        >>> import numpy as np
        >>> import magpylib as magpy
        >>> cube = magpy.magnet.Cuboid(
        ...     dimension=(10, 1, 1),
        ...     polarization=(1, 0, 0)
        ... ).rotate_from_angax(45, 'z')
        >>> J = cube.getJ((3, 3, 0))
        >>> with np.printoptions(precision=3):
        ...    print(J)
        [0.707 0.707 0.   ]
        """
        observers = format_star_input(observers)
        return _getBH_level2(
            self,
            observers,
            field="J",
            sumup=False,
            squeeze=squeeze,
            pixel_agg=pixel_agg,
            output=output,
            in_out=in_out,
        )


class BaseMagnet(BaseSource):
    """Provide magnetization and polarization attributes for magnet sources."""

    _style_class = MagnetStyle

    def __init__(
        self, position, orientation, magnetization, polarization, style, **kwargs
    ):
        super().__init__(position, orientation, style=style, **kwargs)

        self._polarization = None
        self._magnetization = None
        if magnetization is not None:
            self.magnetization = magnetization
            if polarization is not None:
                msg = (
                    "The attributes magnetization and polarization are dependent. "
                    "Only one can be provided at magnet initialization."
                )
                raise ValueError(msg)
        if polarization is not None:
            self.polarization = polarization

    @property
    def magnetization(self):
        """Magnet magnetization vector (A/m) in local coordinates."""
        return self._magnetization

    @magnetization.setter
    def magnetization(self, mag):
        """Set magnetization vector.

        Parameters
        ----------
        mag : None | array-like, shape (3,)
            Magnetization vector M = J/mu0 in units (A/m), given in the local object
            coordinates. Sets also ``polarization``.
        """
        self._magnetization = check_format_input_vector(
            mag,
            dims=(1,),
            shape_m1=3,
            sig_name="magnetization",
            sig_type="array-like (list, tuple, ndarray) with shape (3,)",
            allow_None=True,
        )
        self._polarization = self._magnetization * (4 * np.pi * 1e-7)

    @property
    def polarization(self):
        """Magnet polarization vector (T) in local coordinates."""
        return self._polarization

    @polarization.setter
    def polarization(self, mag):
        """Set polarization vector.

        Parameters
        ----------
        mag : None | array-like, shape (3,)
            Magnetic polarization vector J = mu0*M in units (T), given in the
            local object coordinates. Sets also ``magnetization``.
        """
        self._polarization = check_format_input_vector(
            mag,
            dims=(1,),
            shape_m1=3,
            sig_name="polarization",
            sig_type="array-like (list, tuple, ndarray) with shape (3,)",
            allow_None=True,
        )
        self._magnetization = self._polarization / (4 * np.pi * 1e-7)


class BaseCurrent(BaseSource):
    """Provide scalar electric current attribute for current sources."""

    _style_class = CurrentStyle

    def __init__(self, position, orientation, current, style, **kwargs):
        super().__init__(position, orientation, style=style, **kwargs)
        self.current = current

    @property
    def current(self):
        """Electric current amplitude (A)."""
        return self._current

    @current.setter
    def current(self, current):
        """Set current amplitude.

        Parameters
        ----------
        current : None | float
            Electric current amplitude in units (A).
        """
        # input type and init check
        self._current = check_format_input_scalar(
            current,
            sig_name="current",
            sig_type="None or a number (int, float)",
            allow_None=True,
        )
