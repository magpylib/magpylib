---
orphan: true
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.13.7
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(docs-magpylib-force)=
# Magpylib Force v0.1.10

The package `magpylib-force` provides magnetic force and torque computation between magpylib source objects.

## Installation

Install `magpylib-force` with pip:

```console
pip install magpylib-force
```

## API

The package provides only a single top-level function <span style="color: orange">**getFT()**</span>

```python
import magpylib_force as mforce
mforce.getFT(sources, targets, anchor, eps=1e-5, squeeze=True)
```

Here `sources` are Magpylib source objects that generate the magnetic field. The `targets` are the objects on which the magnetic field acts to create force and torque. So far only `Cuboid`, `Dipole`, and `Polyline` objects can be targets. The `anchor` denotes an anchor point which is the barycenter of the target. If no barycenter is given, homogeneous mass density is assumed and the geometric center of the target is also it's barycenter. `eps` refers to the finite difference length when computing the magnetic field gradient and should be adjusted to be much smaller than size of the system. `squeeze` can be used to squeeze the output array dimensions.

The computation is based on integrating the magnetic field generated by the `sources` over the `targets`, see [here](docs-force-computation) for more details. This requires that each target has a <span style="color: orange">**meshing**</span> directive, which must be provided via an attribute to the object. How `meshing` is defined:
- `Cuboid`: a 3-vector which denotes the number of equidistant splits along each axis resulting in a rectangular regular grid.
- `Dipole`: no meshing required
- `PolyLine`: a scalar which denotes equidistant splits of each PolyLine segment.

The function `getFT()` returns force and torque as `np.ndarray` of shape (2,3), or (t,2,3) when t targets are given.

The following example code computes the force acting on a cuboid magnet, generated by a current loop.

```python
import magpylib as magpy
import magpylib_force as mforce

# create source and target objects
loop = magpy.current.Circle(diameter=2e-3, current=10, position=(0,0,-1e-3))
cube = magpy.magnet.Cuboid(dimension=(1e-3,1e-3,1e-3), polarization=(1,0,0))

# provide meshing for target object
cube.meshing = (5,5,5)

# compute force and torque
FT = mforce.getFT(loop, cube)
print(FT)
# [[ 1.36304272e-03  6.35274710e-22  6.18334051e-20]  # force in N
#  [-0.00000000e+00 -1.77583097e-06  1.69572026e-23]] # torque in Nm
```

```{warning}
[Scaling invariance](guide-docs-io-scale-invariance) does not hold for force computations! Be careful to provide the correct input units!
```


(docs-force-computation)=
# Computation details

The force $F_m$ acting on a magnetic point-dipole moment in a magnetic field $B$ is given by,

$$F_m = âˆ‡(m*B)$$.

The torque $T$ on the point-dipole is,

$$T_m = ð‘š \times B$$.

The idea behind Magplyib-force is to split up a target magnet into a regular mesh of small cells, each of which is then approximated by a magnetic point-dipole in it's barycenter. The computation is vectorized for all dipoles, and the contributions from all cells are summed up to give the total force and torque that acts on the body.

One must not forget that the force, when applied off-center, adds to the torque,

$$T_m' = r \times F$$,

where $r$ is a vector that points from the target magnet barycenter to the dipole.

When dealing with currents, The force 




where 
$ð‘š$ is the magnetic moment of the target object, $F$ is the force acting on the target object, and $r$ is the vector pointing from the dipole moment to the anchor point about which the target rotates.

While analytical solutions exist for special cases of force computation in the literature, there are no general solutions for arbitrary orientations and most geometries provided by Magplyib. However, force and torque acting on magnetic dipole moments are well defined, see above.

The idea behind Magplyib-force is to split up the target body into a regular mesh of small cells, each of which is then approximated by a dipole moment in it's barycenter. The computation of force and torque acting on these moments is then vectorized, and the contributions from all cells are summed up. 

While forces simply add up, torques must be summed up vectorwise with respect to the barycenter of the body.

> [!IMPORTANT]
> Imports are necessairy to run the programm with the functions we want to use. 


<!-- 
### But what is force and torque exactly on the topic of magnetization? 
#### FORCE
In the context of magnetic interactions, the force is a vector quantity that represents the push or pull experienced by a magnetic object due to the presence of another magnetic object. This force can cause the object to move if it is free to do so. The force vector has both a magnitude (how strong the force is) and a direction (the direction in which the force acts).

#### Calculation 

The force ð¹ on a magnetic dipole ð‘š in a magnetic field ðµ is given by:

$$ð¹ = âˆ‡(ð‘š*ðµ)$$

where 
ð‘š is the magnetic moment of the target object. This force is calculated by taking the gradient of the dot product of the magnetic moment and the magnetic field.


<br>

#### TORQUE

Torque, also known as the moment of force, is a measure of the rotational effect produced by the force on a magnetic object. It is a vector quantity that depends on both the magnitude of the force and the distance from the point where the force is applied to the axis of rotation. Torque causes an object to rotate or change its rotational motion. In magnetic interactions, torque is significant when the magnetic moments of the objects interact, causing them to experience rotational forces.

#### Calculation

The torque ð‘‡ on a magnetic dipole ð‘š in a magnetic field ðµ is given by:

 $$ð‘‡ = ð‘š \times ðµ$$

where 
ð‘š is the magnetic moment of the target object. This torque is calculated by taking the cross product of the magnetic moment and the magnetic field.

## For the beginning - Step for Step
We will begin with a straightforward example to illustrate how force and torque calculations work.

### Imports & Functional Code
> [!IMPORTANT]
> Imports are necessairy to run the programm with the functions we want to use. 


{code-cell} ipython3
import numpy as np
import magpylib as magpy
from magpylib_force import getFT
from scipy.spatial.transform import Rotation as R

cube = magpy.magnet.Cuboid(position=(8.,0.,8), dimension=(1.,1.,1.), polarization=(1.,0.,0), orientation=R.from_euler('x', 45, degrees=True))
cube.meshing = (20,20,20)
    
cylinder = magpy.magnet.Cylinder(position = np.array([3.5,0.,6.]), orientation=R.from_euler('y', 70, degrees=True), dimension=(3.5,3.5), polarization=(0.,0.,0.2))

circle = magpy.current.Circle(position = np.array([13.,0.,6.5]), orientation=R.from_euler('y', -55, degrees=True), diameter=5, current = -110000 )

targets = [cube]
sources = [cylinder, circle]

FTs = getFT(sources, targets, anchor=None)
print ("FTs:", FTs)   

In this coe block the magnetic objects are initialized by their position, dimension or diameter, polarization and the orientation. Be aware of, that not every type of object has the same amount of parameters required, to be sure about the construction click [here](https://magpylib.readthedocs.io/en/stable/_pages/user_guide/docs/docs_classes.html) to get more information.  

The allocation, which magnet is a target and which a source is important for the calculation of force and torque. Sources let act the force on targets, so only the targets will be calculated.

The getFT function is included in the magpylib-force package and is executed in the background. The values are printed out.



### Display
{code-cell} ipython3
def display(targets,sources, FTs):

    n_targets = len(targets)
    p = magpy.show(targets + sources, backend='pyvista', return_fig=True,style_legend_show=False)

    FTs = getFT(sources, targets, anchor=None)
    print ("FTs:", FTs)   
    
    for i  in range(n_targets):
        p.add_arrows(cent=targets[i].position, direction=FTs[0,:], mag=1/1500, color='g')
        p.add_arrows(cent=targets[i].position, direction=FTs[1,:], mag=1/1500, color='r')
        

    p.camera.position = (8., -40., 15.)
    p.camera.focal_point = (8,0.,8.)
    return p

p = display(targets, sources, FTs)
p.show()
p.close()

This function displays the output and calculates force and torque. The getFT function is included in the magpylib-force package and is executed in the background. The add_arrows command is important for visualizing the invisible force and torque. The lines of code concerning the camera settings are used to set the camera position and the focal point of the camera.

Outside this function and in the end of this code there are three extra lines, which displays the interactive window, where you can see this forces and torques visualized. 




## Advanced

> [!IMPORTANT]
> Don't forget to copy the code from above first! This code is a developed version of the simple example above. The additions are listed below.

In this example, we simulate and bring to life the dynamic magnetic interactions between a stationary cube magnet and two moving sources: a cylindrical magnet and a current-carrying loop. As the sources traverse their predefined paths, we calculate and display the magnetic forces and torques acting on the cube magnet, culminating in an animated GIF that vividly captures these interactions.

### Functional Code
{code-cell} ipython3
import os
from PIL import Image
import glob

os.makedirs('tmp', exist_ok=True)


for i in range(25):
    p = display(targets,sources,FTs)
    cylinder.move([-0.12,0.,0.])
    circle.move([-0.12,0.,0.])
    p.off_screen = True
    p.screenshot('tmp/{:04d}.png'.format(i))
    p.show()
    p.close()

        
for i in range (25,65) :
    p = display(targets,sources,FTs)
    cylinder.move([0.12,0.,0.])
    circle.move([0.12,0.,0.])
    p.off_screen = True
    p.screenshot('tmp/{:04d}.png'.format(i))
    p.show()

for i in range(65,80):
    p = display(targets,sources,FTs)
    cylinder.move([-0.12,0.,0.])
    circle.move([-0.12,0.,0.])
    p.off_screen = True
    p.screenshot('tmp/{:04d}.png'.format(i))
    p.show()
    p.close() 


Now there are three for loops, and in each for loop, the position of the cylinder and the circle is updated according to the values in brackets. The numbers in brackets represent the naming of the pictures, which will be saved. Overlapping numbers are not allowed, as this would result in the files being overwritten.


### make gif function
python
def make_gif(filename, duration=25, loop=0):
    frames = [Image.open(image) for image in glob.glob(f"tmp/*.png")]
    frames[0].save(
        f"{filename}.gif",
        format="GIF",
        append_images=frames[1:],
        save_all=True,
        duration=duration,
        loop=loop,
        disposal=2, # remove previous image that becomes visible through transparency
    )

make_gif("test", duration=50)         


Additionally, the make_gif function has been added. This function creates a GIF from the pictures saved in the 'tmp' folder.

> [!WARNING]
> Incorrect file savings in the folder will result in a non-functional GIF! If you reduce the numbers in the brackets in the for loops, make sure to delete the folder first to prevent errors in GIF creation. 

<img src="../../../_static/videos/example_force3_gif.gif" width=50% align="center">

> [!NOTE]
> The greater the force or torque, the larger the arrow.


 -->
