---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.13.7
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Collections

(examples-collections-construction)=

## Collection construction

The `Collection` class is a versatile way of grouping and manipulating Magpylib  objects. When objects are added to a Collection they are added by reference (**not copied**) to the attributes `children` (list of all objects), `sources` (list of the sources) and `sensors` (list of the sensors). These attributes are ordered lists. New additions are always added at the end.

```{code-cell} ipython3
import magpylib as magpy

loop = magpy.current.Loop()
sensor = magpy.Sensor()

coll = magpy.Collection(loop, sensor)

print(f"children: {coll.children}")
print(f"sources:  {coll.sources}")
print(f"sensors:  {coll.sensors}")
```

To manipulate existing collections, one can use the `add` and `remove` methods:

```{code-cell} ipython3
coll.add(magpy.magnet.Cuboid())
coll.remove(sensor)

print(f"children: {coll.children}")
print(f"sources:  {coll.sources}")
print(f"sensors:  {coll.sensors}")
```

The operators `+` and `-` provide a similar functionality,

```{code-cell} ipython3
coll = coll - loop
coll = coll + magpy.magnet.Cylinder()

print(f"children: {coll.children}")
print(f"sources:  {coll.sources}")
print(f"sensors:  {coll.sensors}")
```

However, it must be noted that `+` and `-` result in copies of the collection, while `add` and `remove` do not.

The `+` operator is defined for all Magpylib objects. Adding objects returns a collection.

```{code-cell} ipython3
what_is_it = loop + sensor
print(what_is_it)
```

Collections have `__getitem__` through the attribute `children` defined. This allows using collections as iterators,

```{code-cell} ipython3
for child in coll:
    print(child)
```

and makes it possible to directly reference to a child object:

```{code-cell} ipython3
print(coll[0])
```

Finally, it is worth mentioning that collections do not allow duplicate sources. They will automatically be removed. However, sources can be part of multiple collections.

(examples-collections-compound)=

## Compounds

Collections follow the *compound philisophy*. The idea is that a compound object, made up of multiple individual sources and sensors can be treated like single object itself. 

For this purpose, the collection has itself `position` and `orientation` attributes that span a local coordinate reference frame. Whenever a child is added to the collection it has a `position` and `orientation` in the local frame. All operations acting on the collection will then only move the local frame around, and not change child positions within it. Operations acting directly on the child itself will move the child also in the local frame.

```{code-cell} ipython3
import numpy as np
import magpylib as magpy

# construct two coil compounds
coil1 = magpy.Collection()
for z in np.linspace(-.5, .5, 5):
    winding = magpy.current.Loop(current=1, diameter=20, position=(0,0,z))
    coil1.add(winding)
coil1.position = (0,0,-5)
coil2 = coil1.copy(position = (0,0,5))

# construct a helmholz compound
helmholtz = coil1 + coil2

# move the helmholz compound
helmholtz.position = np.linspace((0,0,0), (10,0,0), 30)
helmholtz.rotate_from_angax(np.linspace(0,180,30), 'x', start=0)

# move the winding objects
for coil in [coil1, coil2]:
    for i,w in enumerate(coil):
        w.move(np.linspace((0,0,0), (0,0,2-i), 20))

# move the modified coil compounds
coil1.move(np.linspace((0,0,0), ( 5,0,0), 30))
coil2.move(np.linspace((0,0,0), (-5,0,0), 30))

helmholtz.show(backend='plotly', animation=4, style_path_show=False)
```

The compound philisophy is also followed when computing the magnetic field. Collections behave like single source inputs in the functions `getB` and `getH`. The field that is returned is simply the the sum of the fields of all child sources. In the following example the field generated by the helmholtz compound above, and by the individual coils is computed at position $(0,0,0)$:

```{code-cell} ipython3
helmholtz.reset_path()

print(magpy.getB(helmholtz, (0,0,0)))
print(magpy.getB(coil1, (0,0,0)))
print(magpy.getB(coil2, (0,0,0)))
```

Notice that, `helmholtz.reset_path()` sets the `helmholtz` object to position $(0,0,0)$, however, the final asymmetric structure (coils shifted left and right) remains, so that there is a finite x-component.
